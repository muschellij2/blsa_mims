---
title: "Mapping between minute-level activity measures"
author: "Marta Karas"
date: "`r format(Sys.time(), '%Y-%m-%d')`"
output:
  html_document:
    toc: yes
    toc_depth: 5
  pdf_document:
    toc: yes
    toc_depth: '5'
---

```{r setup, message = FALSE, warning = FALSE}
rm(list = ls())
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, cache = TRUE)
library(tidyverse)
library(mgcv)
library(bivariate) 

gg_base_size <- 12
options(scipen = 999)
```

Reference: https://johnmuschelli.com/upper_limb_gt3x_prosthesis/thresholds.html

### Accelerometry measures master file -- notes 

Accelerometry measures master file is file with merged data of activity counts 
(AC) and open source measures (OSM): MIMS, ENMO, MAD, AI, for (participant, day)
pairs such that: 

- data for participants for which both activity counts (AC) and open source measures (OSM) data exist
- data for participants who have >= 3 valid days
- data form valid days only (both wear and nor-wear minutes)
- data have a matched entry with BLSA covariates file (`mastervisit.rdata`) 

### Read accelerometry measures master file

```{r}
# dat_acc_fpath <- paste0(here::here(), "/data_processed/2021-01-18-measures_masterfile.rds")
dat_acc_fpath <- paste0(here::here(), "/data_processed/2021-01-18-measures_masterfile_winsorized.rds")
dat_acc <- readRDS(dat_acc_fpath)
names(dat_acc)
dim(dat_acc)
length(unique(dat_acc$file_id))
length(unique(dat_acc$subj_id))

# define subset of data
k <- 20
dat_acc_sub <- dat_acc[seq(1, nrow(dat_acc), by = k), ]
dim(dat_acc_sub)

AC_vec <- c(0, 100, 1853, 1952, 2690)
```

### GAM fit 

Note: subset of data (every k-th value) is plotted

#### MIMS ~ AC 

```{r fit_gam_MIMS_AC}
# fit model
mod <- gam(MIMS ~ s(AC, bs = "cr"), data = dat_acc)
# predict
mod_MIMS_AC_df <- data.frame(AC = 0 : round(max(dat_acc$AC)))
mod_MIMS_AC_df$MIMS <- predict(mod, newdata = mod_MIMS_AC_df)
# plot(MIMS ~ AC, mod_MIMS_AC_df)
```

```{r plot_gam_MIMS_AC, fig.width=6, fig.height=6}
x_lim <- c(0, max(mod_MIMS_AC_df$AC))
y_lim <- c(0, mod_MIMS_AC_df %>% filter(AC == x_lim[2]) %>% pull(MIMS))
plt <- 
  ggplot(dat_acc_sub, aes(x = AC, y = MIMS)) + 
  geom_point(alpha = 0.1, size = 0.5) + 
  geom_line(data = mod_MIMS_AC_df, aes(x = AC, y = MIMS), color = "blue") + 
  scale_x_continuous(limits = x_lim) + 
  scale_y_continuous(limits = y_lim) + 
  theme_grey(base_size = gg_base_size)
plt
```

```{r}
mod_MIMS_AC_df %>% filter(AC %in% AC_vec)
```


#### ENMO ~ AC 

```{r fit_gam_ENMO_AC}
# fit model
mod <- gam(ENMO ~ s(AC, bs = "cr"), data = dat_acc)
# predict
mod_ENMO_AC_df <- data.frame(AC = 0 : max(dat_acc$AC))
mod_ENMO_AC_df$ENMO <- predict(mod, newdata = mod_ENMO_AC_df)
```

```{r plot_gam_ENMO_AC, fig.width=6, fig.height=6}
x_lim <- c(0, max(mod_ENMO_AC_df$AC))
y_lim <- c(0, mod_ENMO_AC_df %>% filter(AC == x_lim[2]) %>% pull(ENMO))
plt <- 
  ggplot(dat_acc_sub, aes(x = AC, y = ENMO)) + 
  geom_point(alpha = 0.1, size = 0.5) + 
  geom_line(data = mod_ENMO_AC_df, aes(x = AC, y = ENMO), color = "blue") + 
  scale_x_continuous(limits = x_lim) + 
  scale_y_continuous(limits = y_lim) + 
  theme_grey(base_size = gg_base_size)
plt
```

```{r}
mod_ENMO_AC_df %>% filter(AC %in% AC_vec)
```

#### MAD ~ AC 

```{r fit_gam_MAD_AC}
# fit model
mod <- gam(MAD ~ s(AC, bs = "cr"), data = dat_acc)
# predict
mod_MAD_AC_df <- data.frame(AC = 0 : max(dat_acc$AC))
mod_MAD_AC_df$MAD <- predict(mod, newdata = mod_MAD_AC_df)
```

```{r plot_gam_MAD_AC, fig.width=6, fig.height=6}
x_lim <- c(0, max(mod_MAD_AC_df$AC))
y_lim <- c(0, mod_MAD_AC_df %>% filter(AC == x_lim[2]) %>% pull(MAD))
plt <- 
  ggplot(dat_acc_sub, aes(x = AC, y = MAD)) + 
  geom_point(alpha = 0.1, size = 0.5) + 
  geom_line(data = mod_MAD_AC_df, aes(x = AC, y = MAD), color = "blue") + 
  scale_x_continuous(limits = x_lim) + 
  scale_y_continuous(limits = y_lim) + 
  theme_grey(base_size = gg_base_size)
plt
```

```{r}
mod_MAD_AC_df %>% filter(AC %in% AC_vec)
```


#### AI ~ AC 

```{r fit_gam_AI_AC}
# fit model
mod <- gam(AI ~ s(AC, bs = "cr"), data = dat_acc)
# predict
mod_AI_AC_df <- data.frame(AC = 0 : max(dat_acc$AC))
mod_AI_AC_df$AI <- predict(mod, newdata = mod_AI_AC_df)
```

```{r plot_gam_AI_AC, fig.width=6, fig.height=6}
x_lim <- c(0, max(mod_AI_AC_df$AC))
y_lim <- c(0, mod_AI_AC_df %>% filter(AC == x_lim[2]) %>% pull(AI))
plt <- 
  ggplot(dat_acc_sub, aes(x = AC, y = AI)) + 
  geom_point(alpha = 0.1, size = 0.5) + 
  geom_line(data = mod_AI_AC_df, aes(x = AC, y = AI), color = "blue") + 
  scale_x_continuous(limits = x_lim) + 
  scale_y_continuous(limits = y_lim) + 
  theme_grey(base_size = gg_base_size)
plt
```

```{r}
mod_AI_AC_df %>% filter(AC %in% AC_vec)
```

### Bivariate empirical CDF

Following John's idea. Using 

#### MIMS ~ AC 

```{r fit_bv_MIMS_AC}
W <- 5

bv_MIMS_AC_df <- dat_acc %>% 
  dplyr::mutate(AC = round(AC)) %>%
  dplyr::group_by(AC) %>%
  dplyr::summarise(
    MIMS_cnt = n(),
    MIMS_sum = sum(MIMS), 
    .groups ="drop") %>%
  dplyr::mutate(
    MIMS_cnt_sm = stats::filter(MIMS_cnt, rep(1, W)),
    MIMS_sum_sm = stats::filter(MIMS_sum, rep(1, W)),
    # first and last replace with non-smoothed vals
    MIMS_cnt_sm = ifelse(is.na(MIMS_cnt_sm), MIMS_cnt, MIMS_cnt_sm),
    MIMS_sum_sm = ifelse(is.na(MIMS_sum_sm), MIMS_sum, MIMS_sum_sm),
    MIMS = MIMS_sum_sm / MIMS_cnt_sm
  ) %>%
  dplyr::select(AC, MIMS) %>%
  as.data.frame()

```

```{r plot_bv_MIMS_AC, fig.width=6, fig.height=6}
x_lim <- c(0, max(mod_MIMS_AC_df$AC))
y_lim <- c(0, mod_MIMS_AC_df %>% filter(AC == x_lim[2]) %>% pull(MIMS))
plt <- 
  ggplot(dat_acc_sub, aes(x = AC, y = MIMS)) + 
  geom_point(alpha = 0.1, size = 0.5) + 
  geom_line(data = bv_MIMS_AC_df, aes(x = AC, y = MIMS), color = "blue") + 
  scale_x_continuous(limits = x_lim) + 
  scale_y_continuous(limits = y_lim) + 
  theme_grey(base_size = gg_base_size)
plt
```

```{r}
bv_MIMS_AC_df %>% filter(AC %in% AC_vec)
```

